/**
 * 🎤 SPEAK.JS MELHORADO - Síntese de Voz Moderna
 * Versão otimizada com ES6+, melhor performance e mais funcionalidades
 */

class ModernSpeech {
  constructor(options = {}) {
    this.config = {
      profile: options.profile ?? true,
      fallbackToNative: options.fallbackToNative ?? true,
      autoplay: options.autoplay ?? true,
      volume: options.volume ?? 1.0,
      rate: options.rate ?? 1.0,
      pitch: options.pitch ?? 1.0,
      voice: options.voice ?? null,
      ...options
    };
    
    this.worker = null;
    this.audioContext = null;
    this.isPlaying = false;
    this.queue = [];
    
    this.initializeWorker();
    this.initializeAudioContext();
  }

  // 🔧 Inicializa Worker com fallback
  initializeWorker() {
    try {
      this.worker = new Worker('speakWorker.js');
      console.log('✅ Speech Worker carregado');
    } catch (error) {
      console.warn('⚠️ Worker não disponível, usando fallback:', error.message);
    }
  }

  // 🎵 Inicializa Web Audio API
  initializeAudioContext() {
    try {
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      this.audioContext = new AudioContext();
      console.log('✅ Web Audio API inicializada');
    } catch (error) {
      console.warn('⚠️ Web Audio API não disponível:', error.message);
    }
  }

  // 📊 Parseia arquivo WAV otimizado
  parseWav(wavBuffer) {
    const view = new DataView(wavBuffer.buffer || wavBuffer);
    
    // Verifica header WAV
    const riff = String.fromCharCode(...new Uint8Array(wavBuffer, 0, 4));
    if (riff !== 'RIFF') throw new Error('❌ Não é um arquivo WAV válido');
    
    const compression = view.getUint16(20, true);
    const channels = view.getUint16(22, true);
    const sampleRate = view.getUint32(24, true);
    const bitsPerSample = view.getUint16(34, true);
    
    if (compression !== 1) throw new Error('❌ Compressão inválida, esperado PCM');
    if (channels !== 1) throw new Error('❌ Número de canais inválido, esperado mono');
    
    return {
      sampleRate,
      bitsPerSample,
      channels,
      samples: new Uint8Array(wavBuffer, 44),
      duration: (wavBuffer.length - 44) / (sampleRate * channels * (bitsPerSample / 8))
    };
  }

  // 🎯 Converte para Base64 otimizado
  arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    const binary = Array.from(bytes, byte => String.fromCharCode(byte)).join('');
    return btoa(binary);
  }

  // 🔊 Reproduz usando Web Audio API (melhor performance)
  async playWebAudio(wavData) {
    if (!this.audioContext) return false;
    
    try {
      const audioBuffer = await this.audioContext.decodeAudioData(wavData.samples.buffer.slice());
      const source = this.audioContext.createBufferSource();
      const gainNode = this.audioContext.createGain();
      
      source.buffer = audioBuffer;
      source.playbackRate.value = this.config.rate;
      gainNode.gain.value = this.config.volume;
      
      source.connect(gainNode);
      gainNode.connect(this.audioContext.destination);
      
      return new Promise((resolve) => {
        source.onended = () => {
          this.isPlaying = false;
          resolve();
        };
        
        this.isPlaying = true;
        source.start(0);
      });
      
    } catch (error) {
      console.warn('⚠️ Web Audio falhou:', error.message);
      return false;
    }
  }

  // 🎵 Reproduz usando HTML Audio Element (fallback)
  async playHTMLAudio(wavBuffer) {
    return new Promise((resolve, reject) => {
      try {
        const base64 = this.arrayBufferToBase64(wavBuffer);
        const audio = new Audio(`data:audio/wav;base64,${base64}`);
        
        audio.volume = this.config.volume;
        audio.playbackRate = this.config.rate;
        
        audio.onended = () => {
          this.isPlaying = false;
          resolve();
        };
        
        audio.onerror = (error) => {
          console.error('❌ Erro no HTML Audio:', error);
          reject(error);
        };
        
        this.isPlaying = true;
        audio.play();
        
      } catch (error) {
        reject(error);
      }
    });
  }

  // 🗣️ Usa Speech Synthesis API nativa (fallback final)
  async playNativeSpeech(text, options = {}) {
    if (!('speechSynthesis' in window)) {
      throw new Error('❌ Speech Synthesis API não disponível');
    }
    
    return new Promise((resolve, reject) => {
      const utterance = new SpeechSynthesisUtterance(text);
      
      utterance.volume = options.volume ?? this.config.volume;
      utterance.rate = options.rate ?? this.config.rate;
      utterance.pitch = options.pitch ?? this.config.pitch;
      
      if (this.config.voice) {
        const voices = speechSynthesis.getVoices();
        const selectedVoice = voices.find(voice => 
          voice.name.includes(this.config.voice) || 
          voice.lang.includes(this.config.voice)
        );
        if (selectedVoice) utterance.voice = selectedVoice;
      }
      
      utterance.onend = () => {
        this.isPlaying = false;
        resolve();
      };
      
      utterance.onerror = (error) => {
        console.error('❌ Erro na síntese nativa:', error);
        reject(error);
      };
      
      this.isPlaying = true;
      speechSynthesis.speak(utterance);
    });
  }

  // 🎤 Função principal de síntese de voz
  async speak(text, options = {}) {
    const startTime = performance.now();
    const mergedOptions = { ...this.config, ...options };
    
    try {
      console.log(`🎤 Sintetizando: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"`);
      
      // Método 1: Worker + WAV customizado
      if (this.worker && !mergedOptions.noWorker) {
        try {
          const wavData = await this.synthesizeWithWorker(text, mergedOptions);
          const success = await this.playWebAudio(wavData) || await this.playHTMLAudio(wavData);
          if (success !== false) {
            this.logPerformance('Worker + Web Audio', startTime);
            return;
          }
        } catch (error) {
          console.warn('⚠️ Worker falhou:', error.message);
        }
      }
      
      // Método 2: Speech Synthesis API nativa
      if (mergedOptions.fallbackToNative) {
        await this.playNativeSpeech(text, mergedOptions);
        this.logPerformance('Speech Synthesis API', startTime);
        return;
      }
      
      throw new Error('❌ Nenhum método de síntese disponível');
      
    } catch (error) {
      console.error('❌ Erro na síntese de voz:', error);
      throw error;
    }
  }

  // 🔄 Síntese usando Worker
  async synthesizeWithWorker(text, options) {
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        reject(new Error('⏰ Timeout do Worker'));
      }, 10000);
      
      this.worker.onmessage = (event) => {
        clearTimeout(timeout);
        resolve(this.parseWav(event.data));
      };
      
      this.worker.onerror = (error) => {
        clearTimeout(timeout);
        reject(error);
      };
      
      this.worker.postMessage({ text, args: options });
    });
  }

  // 📊 Log de performance
  logPerformance(method, startTime) {
    if (this.config.profile) {
      const duration = (performance.now() - startTime).toFixed(2);
      console.log(`⚡ ${method}: ${duration}ms`);
    }
  }

  // ⏸️ Para a síntese atual
  stop() {
    this.isPlaying = false;
    
    if ('speechSynthesis' in window) {
      speechSynthesis.cancel();
    }
    
    if (this.audioContext) {
      try {
        this.audioContext.suspend();
      } catch (error) {
        console.warn('⚠️ Erro ao pausar AudioContext:', error);
      }
    }
  }

  // 🔧 Configurações dinâmicas
  setConfig(newConfig) {
    this.config = { ...this.config, ...newConfig };
  }

  // 📋 Lista vozes disponíveis
  getAvailableVoices() {
    if ('speechSynthesis' in window) {
      return speechSynthesis.getVoices().map(voice => ({
        name: voice.name,
        lang: voice.lang,
        isDefault: voice.default
      }));
    }
    return [];
  }

  // 📊 Status atual
  getStatus() {
    return {
      isPlaying: this.isPlaying,
      hasWorker: !!this.worker,
      hasWebAudio: !!this.audioContext,
      hasSpeechSynthesis: 'speechSynthesis' in window,
      config: this.config
    };
  }
}

// 🚀 Instância global para compatibilidade
const modernSpeech = new ModernSpeech();

// 📝 Função compatível com a API original
function speak(text, args = {}) {
  return modernSpeech.speak(text, args);
}

// 🎯 Funções de conveniência
const SpeechUtils = {
  // Fala com configurações específicas
  speakWith: (text, config) => modernSpeech.speak(text, config),
  
  // Para tudo
  stopAll: () => modernSpeech.stop(),
  
  // Configura globalmente
  configure: (config) => modernSpeech.setConfig(config),
  
  // Lista vozes
  listVoices: () => modernSpeech.getAvailableVoices(),
  
  // Status
  status: () => modernSpeech.getStatus(),
  
  // Fala com voz específica
  speakWithVoice: (text, voiceName) => modernSpeech.speak(text, { voice: voiceName }),
  
  // Fala mais rápido/devagar
  speakWithRate: (text, rate) => modernSpeech.speak(text, { rate }),
  
  // Fala com tom específico
  speakWithPitch: (text, pitch) => modernSpeech.speak(text, { pitch })
};

// 🌟 Exportações
if (typeof module !== 'undefined' && module.exports) {
  module.exports = { ModernSpeech, speak, SpeechUtils };
} else {
  window.ModernSpeech = ModernSpeech;
  window.speak = speak;
  window.SpeechUtils = SpeechUtils;
}

// 🎉 Inicialização
console.log('🎤 Modern Speech.js carregado!');
console.log('📋 Uso: speak("Olá mundo!") ou SpeechUtils.speakWith("texto", {rate: 1.5})');
